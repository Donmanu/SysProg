% °_°_°_°_°_°_°_°_°_°_°_
%   PREAMBEL / IMPORTS
% °_°_°_°_°_°_°_°_°_°_°_
\documentclass[
a4paper,   %|letterpaper|a5paper|b5paper|legalpaper|executivepaper,
11pt,      %|10pt|12pt,
oneside,   %|twoside,
onecolumn, %|twocolumn,
final      %|draft,     wie Bilder eingebunden sind
]{article}

% Deutsche Sprache:
\usepackage[utf8]{inputenc} % Ermöglicht die direkte Eingabe der Umlaute.
\usepackage[T1]{fontenc}    % Wird u.a. für das Trennen von Wörtern mit Umlauten genutzt.
\usepackage[ngerman]{babel} % Wird benötigt um deutsche Bezeichnungen zu erhalten. Zum Beispiel 'Inhaltsverzeichnis'
                            % anstelle von 'Table of contents'.  Auch werden dann die Wörter gemäß der _neuen_
                            % Rechtschreibung getrennt.
\addto\captionsngerman{\renewcommand{\abstractname}{Abstract}} % Aber doch Abstract statt "Zusammenfassung"

% Bilder:
\usepackage{graphicx}    % Besserer Bilderimport
\usepackage{wrapfig}     % Erlaube Text um Bilder
\usepackage[font={small,it},labelfont={normal}]{caption}  % Bessere Bild-/Code-/Tabellenuntertitel
\usepackage{tikz}        % Erlaubt das Malen von z.B. State Machines
\usetikzlibrary{positioning,shapes,shadows,arrows}

% Schrift und Optik:
\usepackage{geometry}
\usepackage{concrete}    % Ganz hübsche Schriftart von Donald himself
\geometry{a4paper,left=28mm,right=28mm, top=38mm, bottom=38mm}
\usepackage{setspace}
\onehalfspacing          % Anderhalbfacher Zeilenabstand
\widowpenalty = 10000
\clubpenalty = 10000

% Code:
\usepackage{courier}     % Mache \ttfamily zum Courier-Font
\usepackage{color}       % Vor allem für farbigen Code
\definecolor{lightgray}{rgb}{ .97, .97, .97 }
\definecolor{lightgrey}{rgb}{ .97, .97, .97 }
\definecolor{shadow}{rgb}   { .75, .75, .75 }
\definecolor{darkgray}{rgb} { .4 , .4 , .4  }
\definecolor{darkgrey}{rgb} { .4 , .4 , .4  }
\definecolor{blue}{rgb}     { .0 , .15, .45 }    % redefine
\definecolor{purple}{rgb}   { .6 , .1 , .75 }
\definecolor{deepblue}{rgb} { .15, .0 , .5  }
\definecolor{darkblue}{rgb} { .0 , .0 , .33 }

\usepackage{listings}    % Code-Listings

\lstdefinelanguage{PseudoCode}{
  basicstyle=\small\ttfamily,
  identifierstyle=\color{black},
  sensitive=false,
  comment=[l]{\#}{//}{;},
  morecomment=[s]{/*}{*/},
  commentstyle=\color{darkgray}\ttfamily,
  stringstyle=\color{red}\ttfamily,
  morestring=[b]',
  morestring=[b]", % shorter delimiter first!
  morestring=[b]"""
}

\lstdefinelanguage{SysProgLang}{
  basicstyle=\small\ttfamily,
  identifierstyle=\color{black},
  sensitive=true,
  comment=[l]{:*},
  morecomment=[s]{:*}{*:},
  commentstyle=\color{darkgray}\ttfamily,
  %stringstyle=\color{red}\ttfamily,
  %morestring=[b]',
  %morestring=[b]",
  %morestring=[b]"""
}
%\usepackage{mathtools} % mainly for := sign, but mathtools is not available :(
% So we define our own ":=" ...
% http://tex.stackexchange.com/questions/4216/how-to-typeset-correctly
\newcommand*{\defeq}{\mathrel{\vcenter{\baselineskip0.5ex \lineskiplimit0pt
                     \hbox{\scriptsize.}\hbox{\scriptsize.}}}
                     =}
\lstset{
  basicstyle=\small\ttfamily, % make monospac
  backgroundcolor=\color{lightgray},
  columns=fixed,    % make monospace?
  keepspaces=true,
  basewidth=0.60em,
  frame=shadowbox,
  rulecolor=\color{shadow},
  rulesepcolor=\color{shadow}, % shadow color
  numbers=left,
  numbersep=5pt,    % how far the line-numbers are from the code
  showspaces=false,
  showstringspaces=false,
  captionpos=b,     % bottom
  xleftmargin=2em,   % enough for 99 lines
  escapechar=!     % LaTeX inside code segments
}
\renewcommand\lstlistingname{Quelltext} % Sag Babel, wie es das Label "Listing" übersetzen soll
\renewcommand\lstlistlistingname{Quelltextverzeichnis} % Sag Babel, wie es den Titel "Listings" übersetzen soll

% short hand macro. Use like \code{var example = 1;}
\newcommand{\code}[1]{\lstinline$#1$}

% Referenzen:
\usepackage[nospace,sort]{cite}     % Zitiernummermanagement
\renewcommand{\thefootnote}{\roman{footnote}} % Römische Nummerierung für Fußnoten

% LAST IMPORT, URLs und links:
\usepackage{hyperref}    % Get clickable links, refs, figs, chapters ... SHOULD BE LAST IMPORT!
\hypersetup{
    colorlinks=false, % false doesn't work?
    linktocpage=true
    %linkcolor=blue,
    %filecolor=magenta,      
    %urlcolor=cyan,
}
% END IMPORTS



% META INFO:
\title{Systemnahe Programmierung eines Compilers\\I. Der Scanner}

\author{
Manuel \textsc{Giesinger} \hspace{1cm} \texttt{gima1019@hs-karlsruhe.de}
\and
Arthur \textsc{Jagiella} \hspace{1.35cm} \texttt{jaar1013@hs-karlsruhe.de}
}
\date{\today}



% °_°_°_°_°_°_°_°_°_°_°_
%    BEGIN DOCUMENT:
% °_°_°_°_°_°_°_°_°_°_°_
\begin{document}

%\include{mytitle}  % als externe .tex-Datei
\pagenumbering{gobble}
\maketitle
\newpage

\tableofcontents
\newpage


% °_°_°_°_°_°_°_°_°_°_°_
%    MAIN MATTER
% °_°_°_°_°_°_°_°_°_°_°_
\pagenumbering{arabic}

\section{Einleitung} % sub-, subsub-, paragraph, subparagraph
Diese Arbeit ist im Rahmen der Laborübung „Systemnahes Programmieren“ im Studiengang Informatik (B.Sc.) an der Hochschule Karlsruhe im Sommersemester 2017 entstanden. 

\subsection{Aufgabenstellung gesamt}
Im Kurs „Systemnahes Programmieren“ geht es inhaltlich um die Programmierung in C++ unter weitgehendem Verzicht auf die Nutzung von Standardbibliotheken. Die Implementierung von Puffern, verketteten Listen, Hashtabellen und Baumstrukturen soll per Hand erfolgen. Hierzu wird als Anwendung ein Compiler für eine fiktive Sprache implementiert.

\subsection{Aufgabenstellung Scanner -- diese Arbeit} 
Als Teil des Compilers ist die Aufgabe des Scanners eine Source-Datei einzulesen und in ihre syntaktischen Bestandteile zu zerlegen - man pricht von \emph{tokenizing}. Dazu bedarf es zum einen eines Puffer-Speichers für den Dateiinhalt. Zum anderen ist die Token-Erkennung mithilfe eines deterministischen endlichen Automaten umgesetzt.
Parallel zur syntaktischen Analyse werden bereits erste Informationen über die Token gesammelt. Diese hält eine Symboltabelle bereit, welche als hash-map realisiert wird.

Im folgenden wird von den Datenstrukturen \code{Token}, \code{Key} und \code{Information} gesprochen. Die genauere Beschreibung dieser findet sich später in den Kapiteln \ref{sec:symtab} und \ref{sec:scanner}.

\section{Der Puffer}

\subsection{Aufgabe des Puffers}
Um die Langsamkeit der I/O-Operationen der Festplatte abzufedern, wird die zu kompilierende Datei in den Arbeitsspeicher geladen.
Da dies bei sehr großen Dateien widerrum Probleme bereiten kann, geschieht dies in Schritten von 512 Byte.
Der Puffer bietet an den Inhalt der Datei Zeichen für Zeichen zu erhalten.
Außerdem erlaubt er, wieder zurück im Zeichenstrom zu gehen (siehe Automat \ref{sec:autom}).

\subsection{Erklärung der Funktion}
Der Puffer besteht aus zwei Speicherbereichen (jeweils 512 Bytes groß).
Diese werden wechselseitig mit dem Inhalt der zu kompilierenden Datei gefüllt.
Die Speicherbereiche werden dabei nur einmal angelegt und durch das Umlegen eines entsprechenden Zeigers angesprochen.
Um das Neu-Einlesen des nächsten Datei-Chunks zu steuern, existiert außerdem eine Bool'sche Variable, die angibt, ob der nächste Speicherbereich alt ist und neu eingelesen werden muss.
Oder ob er bereits neu befüllt wurde und wir durch ein \code{unget()} oder initial in den aktuell hinteren Bereich gelangt sind.

Am Ende der Datei liefert der Puffer ein Nullterminal \code{'\0'}.

\subsection{Implementierung}
Um höchste Performanz zu erreichen, erfolgt die Allokierung des Speicherbereichs mittels \code{posix_memalign(...)} mit einem \emph{alignment} des Speichers, welches der Puffergröße entspricht.
Dies beugt Fragmentierung vor und beschleunigt das Einlesen von einem \emph{block-device} unter Linux.

Beim ersten Einlesen mittels \code{ssize_t read (int, void*, size_t)} wird versucht gleich beide Bereiche zu füllen, wenn die Datei groß genug ist.
Wir starten also im hinteren Puffer; die Bool'sche Variable ist initial entsprechend \code{was_swapped_back = true;} gesetzt.
Dies erlaubt eine einfachere Behandlung des unwahrscheinlichen Falls, dass ein \code{unget()} zu Beginn der Datei aufgerufen wird.

Der Puffer bietet nach außen (gegenüber dem Automaten) in erster Linie zwei Funktionen an:
\begin{description}
\item \code{char Buffer::get(void)} um das nächste Zeichen der Datei zu erhalten.
\item \code{void Buffer::unget(void)} um im Puffer ein Zeichen zurück zu gehen.
\end{description}
Alle weiteren Funktionen sind privat und dienen dem Management von Datei-Ein-/Ausgabe und Speicherverwaltung.




\section{Der Automat} \label{sec:autom}

\subsection{Aufgabe des Automaten}
Der Automat hat die Aufgabe in einer Zeichensequenz eine Tokensequenz zu erkennen.
Dazu wird die Logik eines \emph{endlichen deterministischen Automaten} (FSM, \emph{finite state machine}) genutzt, wie in \ref{fig:autom} abgebildet.
Ein FSM ist dazu geeignet, eine reguläre Grammatik (\textsc{Chomsky}-Hierarchie 3) zu erkennen, was für diesen Zweck völlig ausreichend ist. Dies dient als Vorstufe, damit der Parser in der \textsc{Chomsky}-Hierarchie 2 der kontextfreien Sprachen arbeiten kann.
Die Eingabe in den Automaten ist das jeweils nächste Zeichen in der zu kompilierenden Datei.
In den Zuständen des Automaten passiert nichts, dafür bei den Übergängen -- wir haben also einen \textsc{Mealy}-Automaten.
Da in Kommentaren der Sprache alle Zeichen erlaubt sind, ist das Alphabet des Automaten effektiv unendlich groß.
Praktisch lesen wir zum einen nur 8-bit-Werte ein (C++ \code{char}-Typ) und prüfen zum anderen nur auf ASCII-Zeichen.
So lässt sich das Alphabet mit $\sum = [0-9A-Za-z-+:*<>=:!\&;()[]\{\}'\backslash0']$ beschreiben.

Im Übrigen wird im Automaten aufgezeichnet, in welcher Zeile und Spalte der Datei wir uns gerade befinden, da hier (neben dem Buffer) sicher jedes Zeichen einmal behandelt wird und bekannt ist, ob per \code{unget()} doppelt gelesen wurde.
Dazu wird auch die Variable \code{int Automat::count} verwendet, welche so einen mehrfachen Zweck erfüllt:
\begin{enumerate}
\item Sie zeichnet auf, wie weit zurück ein \code{unget()} gehen muss.
\item Sie merkt sich, wo der Beginn des aktuellen Tokens ist. In Compilern ist es üblich, Warnungen mit Zeilen- und Spaltennummern auf den Beginn eines Tokens zu beziehen. Dies tun wir damit genau so.
\item Sie gibt die länge des aktuell zwischengespeicherten Strings an, der entweder mit \code{long strtol(char*)} ausgewertet, oder in der Symboltabelle gespeichert, oder als unbekanntes Zeichen ausgegeben wird.
\end{enumerate}

\subsection{Implementierung}
Für die Umsetzung eines FSM gibt es hauptsächlich zwei Ansätze:
%\begin{itemize} broken somehow:
% No creation rule for font xccsy10
% Font OMS/ccr/m/n/10.95=xccsy10 at 10.95pt not loadable
\begin{description}
\item{Per Adjazenz-Matrix} mit der Dimension $|\mathit{Alphabet}| \times |\mathit{States}|$, in welcher der Zielzustand eines Übergangs von einem Startzustand bei einem Eingabezeichen verzeichnet ist. Der Nachteil ist die Größe dieser Tabelle bei unserem Eingabealphabet.
\item{Durch direkte Implementierung} der Übergänge als Funktionen, bzw. als \code{switch-case}-Weichen innerhalb der \code{read(char)} Methode eines jeden Zustands.
\end{description}
Wir wählten den zweiten Ansatz.
Dazu erstellten wir eine Klassenhierarchie wie in \ref{fig:states} zu sehen.

\begin{figure}[Htb] % outer wrapper
\begin{center}
\begin{tikzpicture}[node distance=0.5cm]
% See http://www.texample.net/tikz/examples/class-diagram/

% Definitions
\tikzstyle{abstract}=[rectangle, draw=black, rounded corners, fill=gray!15, drop shadow,
        text centered, anchor=north, text=black, text width=4.7cm, scale=0.88]
\tikzstyle{inherit}=[->, >=open triangle 90, thick]
\tikzstyle{line}=[-, thick]

\node (Mother) [abstract, rectangle split, rectangle split parts=2]
        {
            \textbf{State \\ \textit{<<abstract>>}}
            \nodepart{second}void read(char, FSM*)\\State getState(void)
        };

% Ugly hack: using three nodes, to make room below Mother:
\node (AuxNode_StateAnchor) [text width=0.5cm, below=of Mother] {};
\node (AuxNode_StateAnchor2) [text width=0.5cm, below=of AuxNode_StateAnchor] {};
\node (AuxNode_StateAnchor3) [text width=0.5cm, below=of AuxNode_StateAnchor2] {};

\node (Child2) [abstract, rectangle split, rectangle split parts=2, left=of AuxNode_StateAnchor3]
        {
            \textbf{StateRestart}
            \nodepart{second}void read(char, FSM*)\\StateRestart getState(void)
        };
\node (Child1) [abstract, rectangle split, rectangle split parts=2, left=of Child2]
        {
            \textbf{StateStart}
            \nodepart{second}void read(char, FSM*)\\StateStart getState(void)
        };

\node (ChildN) [abstract, rectangle split, rectangle split parts=2, right=of AuxNode_StateAnchor3]
        {
            \textbf{StateAnd}
            \nodepart{second}void read(char, FSM*)\\StateAnd getState(void)
        };

% Inheritance lines
\draw[inherit] (Child2.north) -- ++(0,0.7) -| (Mother.south);
\draw[inherit] (Child1.north) -- ++(0,0.7) -| (Mother.south);
\draw[inherit] (ChildN.north) -- ++(0,0.7) -| (Mother.south);

% Ellipsis. Below center of picture at Mother.north
\fill[gray!40] (-0.4,-3.9) circle (0.12);
\fill[gray!40] (0.0,-3.9) circle (0.12);
\fill[gray!40] (0.4,-3.9) circle (0.12);

\end{tikzpicture}
\end{center}
\caption{(Gekürztes) Klassendiagramm der Zustände.} \label{fig:states}
\end{figure}

Wir folgten bei der Implementierung der Logik, dass diese Zustände für sich stehen, und nicht mit jedem für eine zu kompilierende Datei erstellten Automaten instantiiert werden müssen.
Daher sind diese Klassen \code{static} definiert. Der Automat übergibt sich selbst (\code{this}) an den lesenden Zustand.
Dieser setzt dann den neuen Zustand im Automaten und ruft u.U. über diesen den Scanner auf, um ein Token zu erzeugen.
Vgl. dazu Quelltext \ref{lst:state}.

Bei diesem Ansatz ist die ODR-Regel \footnote{\emph{ODR: one definition rule}} in C/C++ zu beachten, nach der die Definition der entsprechenden statischen Instanzen nur genau einmal erfolgen darf und muss.
Wir brachten diese Definitionen dazu in einer eigenen Header-Datei unter, welche mit den entsprechenden \emph{include guards} versehen ist.

Die Zustände erwarten über den Automaten die Methode \code{Scanner::mkToken(TokenType)} aufrufen zu können.
Außerdem fügen sie mittels \code{Automat::incrementAndAppend(char)} an entsprechender Stelle Zeichen zur späteren Verarbeitung hinzu.

Wir haben mit dem Zustand \texttt{StateRestart} einen besonderen Zustand eingebaut, der dazu da ist einen kontrollierten Übergang nach einem \code{mkToken()} zurück in \texttt{Start} durchzuführen.
Restart wird betreten, wenn die Variable \code{Automat::count} zurückgesetzt werden muss und das letzte Zeichen nochmal von Start eingelesen wird (sprich, ein \code{unget(1)} passiert).
Dazu ist nicht unbedingt dieser spezielle Zustand nötig.
Wir fanden das aber eine elegante Lösung als Ersatz für sich überall wiederholenden Code.

Andere Zustände, die logisch erscheinen, haben wir widerrum eingespart.
Es gibt zum Beispiel fast keine finalen Zustände jenseits von \texttt{Start}.
Stattdessen geschieht das Akzeptieren einer Zeichensequenz in anderen Zuständen mit einem Übergang in Start, respektive Restart, und der zugehörigen Tokenerzeugung. Somit verfügen unsere Zustände auch nicht über ein Attribut \code{bool State::isFinal} oder dergleichen.

\subsection{Aufbau der Zustände}

Der Aufbau des Automaten bzw. die Zusammenhänge der Zustände in \texttt{states.cpp} ist in Bild \ref{fig:autom} gezeigt. Es sind zwar logische Endzustände als solche markiert. Dies hat für den Ablauf aber keiner weitergehende Bedeutung. Es zählt vor allem, welche Funktionen bei den Übergängen aufgerufen werden.

Die Methode \code{Scanner::mkToken(TokenType)} löst im Scanner die Erzeugung eines Tokens aus. Die Methode \code{void Automat::increment(void)} erhöht die Variable \code{int Automat::count} um $1$, wohingegen \code{void Automat::incrementAndAppend(char)} dies ebenfalls tut, aber zusätzlich das jeweilige Zeichen für die spätere Aufzeichnung in der Symboltabelle bzw. Berechnung mittels \code{strtol()} vorhält.

%% AUTOMATEN-Bild 1: Die wichtigsten Zustände
\begin{figure}[Htb] % outer wrapper
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
% Base generated with http://madebyevan.com/fsm/

% As can be seen on https://www.sharelatex.com/learn/TikZ_package#/Diagrams
% This code could be designed much more readable and maintainable like:
%   \draw[->] (RestartNode.west) -- (StartNode.east);
% but madebyevan.com didn't do that :(

% States:
\draw [black] (22.4,-26.2) circle (3.5);
\draw [black] (22.4,-26.2) circle (2.8);
\draw (22.4,-26.2) node {$Start$};

\draw [black] (48.5,-28.2) circle (3.5);
\draw [black] (48.5,-28.2) circle (2.8);
\draw (48.5,-28.2) node {$Numb.$};

\draw [black] (22.4,-47.5) circle (3.5);
\draw [black] (22.4,-47.5) circle (2.8);
\draw (22.4,-47.5) node {$Ident.$};

\draw [black] (51.1,-47.5) circle (3.5);
\draw (51.6,-47.8) node {$Restart$};

\draw [black] (74.5,-9.8) circle (3.5);
\draw [black] (74.5,-9.8) circle (2.8);
\draw (74.5,-9.8) node {$Colon$};

\draw [black] (45.8,-7.8) circle (3.5);
\draw (45.8,-6.8) node {$ComBegin$};

\draw [black] (22.4,-7.8) circle (3.5);
\draw (22.4,-6.8) node {$ComEnd$};

% Lines:
\draw [black] (25.39,-26.43) -- (45.51,-27.97);
\fill [black] (45.51,-27.97) -- (44.75,-27.41) -- (44.67,-28.41);
\draw [blue] (35.11,-27.3) node [above] {\small$append(...)$};
\draw (35.11,-27.9) node [below] {$[0-9]$};		% Start > Num

\draw [black] (49.83,-25.524) arc (181.30395:-106.69605:2.25);
\fill [black] (51.43,-27.63) -- (52.24,-28.11) -- (52.22,-27.11);
\draw [blue] (54.44,-26) node [right] {\small$append(...)$};
\draw (54.44,-23.8) node [right] {$[0-9]$};		% Num > Num

\draw [black] (22.4,-29.2) -- (22.4,-44.5);
\fill [black] (22.4,-44.5) -- (22.9,-43.7) -- (21.9,-43.7);
\draw [blue] (21.9,-39.05) node [left] {\small$append(...)$};
\draw (21.9,-36.85) node [left] {$[A-Za-z]$};		% Start > Id

\draw [black] (23.3,-50.35) arc (45.25384:-242.74616:2.25);
\fill [black] (20.69,-49.95) -- (19.77,-50.16) -- (20.48,-50.87);
\draw [blue] (18.97,-57.46) node [below] {\small$append(...)$};
\draw (18.97,-55.26) node [below] {$[0-9A-Za-z]$};	% Id > Id

\draw [black] (48.9,-31.17) -- (50.7,-44.53);
\fill [black] (50.7,-44.53) -- (51.09,-43.67) -- (50.1,-43.8);
\draw [blue] (49.12,-39.2) node [left] {\small$mkToken(Integer)$};
\draw (49.12,-37) node [left] {$default$};			% Num > Restart

\draw [black] (25.4,-47.5) -- (48.1,-47.5);
\fill [black] (48.1,-47.5) -- (47.3,-47) -- (47.3,-48);
\draw (36.75,-48) node [below] {$default$};		% Id > Restart
\draw [blue] (36.75,-50.2) node [below] {\small$mkToken(Identifier)$};

\draw [black] (48.69,-45.71) -- (24.81,-27.99);
\fill [black] (24.81,-27.99) -- (25.15,-28.87) -- (25.75,-28.06);
\draw [blue] (37.25,-34.35) node [above] {\small$resetCounter()$};
\draw (37.25,-35.85) node [above] {$\epsilon$};		% Restart > Start

\draw [black] (19.588,-27.211) arc (317.50021:29.50021:2.25);
\fill [black] (19.89,-24.58) -- (19.64,-23.67) -- (18.96,-24.41);
\draw [blue] (15.04,-26.52) node [left] {\small$mkToken(...)$};
\draw (15.04,-24.32) node [left] {$[+-*<>=!;()[]{}]$}; % Start > Start

\draw [black] (44.477,-5.12) arc (234:-54:2.25);
\fill [black] (47.12,-5.12) -- (48,-4.77) -- (47.19,-4.18);
\draw (45.8,-0.55) node [above] {$default$};		% ComBegin > ComBegin

\draw [black] (42.8,-7.8) arc (80:100:50);
\fill [black] (25.4,-7.8) -- (26.3,-8.2) -- (26.1,-7.2);
\draw (34.1,-6.3) node [above] {$[*]$};			% ComBegin > ComEnd

\draw [black] (42.8,-7.8) arc (-80:-100:50);
\fill [black] (42.8,-7.8) -- (41.9,-7.4) -- (42.1,-8.4);
\draw (34.1,-9.3) node [below] {$default$};		% ComEnd > ComBegin

\draw [black] (21.1,-5.12) arc (234:-54:2.25);
\fill [black] (23.8,-5.12) -- (24.68,-4.77) -- (23.87,-4.18);
\draw (22.4,-0.55) node [above] {$[*]$};		% ComBegin > ComBegin

\draw [black] (22.4,-10.8) -- (22.4,-23.2);
\fill [black] (22.4,-23.2) -- (22.9,-22.4) -- (21.9,-22.4);
\draw (21.9,-17.6) node [left] {$[:]$};			% ComEnd > Start

\draw [black] (25.26,-25.3) arc (-80:-66.8:208);
\fill [black] (71.64,-11.5) -- (70.73,-11.25) -- (71.03,-12.22);
\draw [blue] (56.6,-19.4) node [below] {\small$increment()$};
\draw (49.87,-19.8) node [below] {$[:]$};			% Start > Colon

\draw [black] (71.6,-11.3) arc (100:113.2:208);
\fill [black] (25.26,-25.1) -- (25.9,-24.35) -- (26.22,-25.3);
\draw [blue] (39.5,-17.57) node [above] {\small$mkToken(ColEqu)$};
\draw (48.5,-16.57) node [above] {$[=]$};			% Colon > Start

\draw [black] (72.92,-12.35) -- (52.68,-44.95);
\fill [black] (52.68,-44.95) -- (53.53,-44.54) -- (52.68,-44.01);
\draw [blue] (64,-29.56) node [right] {\small$mkToken(Colon)$};
\draw (64,-27.36) node [right] {$default$};		% Colon > Restart

\draw [black] (71.5,-9.8) -- (48.8,-7.8);
\fill [black] (48.8,-7.8) -- (49.6,-8.3) -- (49.6,-7.3);
\draw (60.15,-8.3) node [above] {$[*]$};			% Colon > ComBegin
\end{tikzpicture}
\caption{Die Zuständes des Automaten, welche die Token(gruppe) \texttt{SingleSign}, \texttt{Identifier} und \texttt{Number} erzeugen, sowie Kommentare übergehen. $default$ steht hier für den Rest von $\sum$, der keinen anderen Übergang aus diesem Knoten hat.} \label{fig:autom}
\end{center}
\end{figure}

%% AUTOMATEN-BILD 2, der Rest:
\begin{figure}[Htb]
\begin{center}
\begin{tikzpicture}[scale=0.2]
\tikzstyle{every node}+=[inner sep=0pt]
% States
\draw [black] (57.7,-29.9) circle (3.5);
\draw [black] (57.7,-29.9) circle (2.8);
\draw (57.7,-29.9) node {$Start$};

\draw [black] (27.1,-29.9) circle (3.5);
\draw (27.1,-29.9) node {$Restart$};

\draw [black] (53.2,-7.4) circle (3.5);
\draw (53.2,-7.4) node {$And$};

\draw [black] (57.7,-52.2) circle (3.5);
\draw [black] (57.7,-52.2) circle (2.8);
\draw (57.7,-52.2) node {$Equ$};

\draw [black] (11,-51.2) circle (3.5);
\draw (10.9,-51.2) node {$EquCol$};

\draw [darkgray] (15.6,-12.6) circle (3.5);
\draw [darkgray] (15.6,-12.6) node {$X$};

% Lines
\draw [black] (60.38,-28.577) arc (144:-144:2.25);
\fill [black] (60.38,-31.22) -- (60.73,-32.1) -- (61.32,-31.29);
\draw [blue] (64.95,-31.9) node [right] {\small$append(?)$};
\draw [blue] (64.95,-34.1) node [right] {\small$mkToken(Unknown)$};
\draw (64.95,-29.9) node [right] {$?$};				% Start > Start

\draw [black] (30.1,-29.9) -- (54.7,-29.9);
\fill [black] (54.7,-29.9) -- (53.9,-29.4) -- (53.9,-30.4);
\draw [blue] (42.4,-30.0) node [above] {\small$resetCounter()$};
\draw (42.4,-30.4) node [below] {$\epsilon$};			% Restart > Start

\draw [black] (57.11,-26.96) arc (5:16.2:86);
\fill [black] (54.15,-10.34) -- (53.7,-11.22) -- (54.7,-11.03);
\draw [blue] (57.4,-20.54) node [right] {\small$append(\&)$};
\draw (57.4,-18.34) node [right] {$[\&]$};				% Start > And

\draw [black] (53.79,-10.34) arc (-175:-163.8:87);
\fill [black] (56.8,-27.2) -- (57.15,-26.28) -- (56.15,-26.47);
\draw [blue] (53.5,-22.16) node [left] {\small$mkToken(And)$};
\draw (53.5,-19.96) node [left] {$[\&]$};				% And > Start

\draw [black] (50.93,-9.36) -- (29.37,-27.94);
\fill [black] (29.37,-27.94) -- (30.3,-27.8) -- (29.65,-27.04);
\draw [blue] (36.19,-18.16) node [below] {\small$mkToken(Unknown)$};
\draw (36.19,-17.96) node [above] {$default$};			% And > Restart

\draw [black] (57.7,-32.9) -- (57.7,-49.2);
\fill [black] (57.7,-49.2) -- (58.2,-48.4) -- (57.2,-48.4);
\draw [blue] (58.4,-41.05) node [right] {\small$increment()$};
\draw (57.2,-41.05) node [left] {$[=]$};				% Start > Equ

\draw [black] (54.7,-52.14) -- (14,-51.26);
\fill [black] (14.2,-51.26) -- (15,-51.78) -- (15,-50.78);
\draw [blue] (34.37,-52.37) node [below] {\small$increment()$};
\draw (34.37,-51.17) node [above] {$[:]$};				% Equ > EquCol

\draw [black] (13.73,-49.96) -- (54.97,-31.14);
\fill [black] (54.97,-31.14) -- (54.04,-31.02) -- (54.45,-31.93);
\draw [blue] (36.1,-40.07) node [above] {\small$mkToken(UnEqual)$};
\draw (36.1,-41.07) node [below] {$[=]$};				% EquCol > Start

\draw [black] (55.28,-50.43) -- (29.52,-31.67);
\fill [black] (29.52,-31.67) -- (29.88,-32.54) -- (30.47,-31.73);
\draw [blue] (48.35,-42.4) node [below] {\small$mkToken(Equals)$};
\draw [blue] (48.35,-44.5) node [below] {\small$unget(1)$};
\draw (48.35,-42.1) node [above] {$default$};			% Equ > Restart

\draw [black] (12.81,-48.81) -- (25.29,-32.29);
\fill [black] (25.29,-32.29) -- (24.41,-32.63) -- (25.21,-33.23);
\draw [blue] (17.8,-38.75) node [left] {\small$mkToken(Equals)$};
\draw [blue] (17.8,-40.95) node [left] {\small$unget(2)$};
\draw (19,-40.95) node [right] {$default$};			% EquCol > Restart

\draw [darkgray] (17.26,-15.1) -- (25.44,-27.4);
\fill [darkgray] (25.44,-27.4) -- (25.41,-26.46) -- (24.58,-27.01);
\draw [blue] (20,-22.78) node [left] {\small$append(?)$};
\draw [blue] (20,-25) node [left] {\small$mkToken(Unknown)$};
\draw [black] (20,-20.58) node [left] {$?$};			% X > Restart
\end{tikzpicture}
\end{center}
\caption{Die Zuständes des Automaten, welche die Token \texttt{And}, \texttt{Equal}, \texttt{ColonEqual}, \texttt{UnEqual} und \texttt{Unknown} erzeugen.
Die Zustände \texttt{Start} und \texttt{Restart} sind die selben wie in Abbildung \ref{fig:autom}.
Der Zustand \texttt{X} steht für jeden möglichen der anderen Zustände dort, außer \texttt{comBegin} und \texttt{comEnd}, da dort nicht-Alphabet Buchstaben erlaubt sind. Das \texttt{?} steht für ein Zeichen außerhalb des Automaten-Alphabets. Das Nullterminal (EOF) ist der Übersichtlichkeit wegen nicht verzeichnet.} \label{fig:autom2}
\end{figure}

Jeder der Zustände implementiert dann die entsprechenden Übergänge mittels einer switch-case-Struktur.
Diese ist beispielhaft für den Zustand \texttt{Number} in Listing \ref{lst:state} gezeigt.

% TODO check in final version if listing gets split by fig:autom2
%\begin{minipage}{\linewidth} % avoids pagebreaks inside, but placement may be bad
\begin{lstlisting}[float, language=C++, firstnumber=116, caption={Ausscchnitt aus \texttt{states.cpp}. Die \code{read()}-Methode des Zustands \texttt{Number}.}, label=lst:state]
void StateNumber::read(char c, Automat* m) {
  switch (c) {
  case '0' ... '9':
    // integer continues
    m->incrementAndAppend(c);  // remember c for later strtol()
    // stay in StateNumber
    break;
  case ' ':
  case '\n':
  case '\t':
    // shortcut: don't re-read whitespace
    m->setCurrentState(StateStart::makeState());
    m->getScanner()->mkToken(TokenType::TokenInteger);
    break;
  default:
    // integer is finished:
    m->getScanner()->mkToken(TokenType::TokenInteger);
    m->setCurrentState(StateRestart::makeState());  // re-read c
    m->getCurrentState()->read(c, m);      // epsilon transition
  }
}
\end{lstlisting}
%\end{minipage}



\section{Die Symboltabelle} \label{sec:symtab}

\subsection{Aufgabe der Symboltabelle}
Die Symboltabelle enthält weitergehende Informationen über Identifier-Token, insb. ob gefundene Identifier einem \emph{keyword} der Sprache entsprechen oder sonst bereits bekannt sind.
Hierzu verfügt die Symboltabelle über einen Speicher aller einzigartigen Identifier-Strings, welche mit den Keywords initialisiert wird.

In Abbildung \ref{fig:tokkeyinf} ist der Zusammenhang zwischen dem \code{struct Token} und den Klassen \code{Key}, \code{Information} und der Stringtablle gezeigt.
Das Token, der letztlich vom Scanner zurückgegeben wird, enthält zusätzlich zu seinem Typ, Zeile und Spalte noch einen Key-Pointer, falls es sich um einen Identifier handelt, oder ein \code{long int value} im Falle eines TokenInteger.
Der Key kommt von der Symboltabelle und enthält neben dem \code{hash} ein Informationsobjekt.
Dieses erfüllt hier noch keinen großen Zweck, sondern wird erst später beim Parser nützlich werden.
Soweit enthält es nur einen Pointer auf das Lexem des Identifiers in der Stringtabelle.


\subsection{Implementierung}

\begin{figure}[Htb] % outer wrapper
\begin{center}
\begin{tikzpicture}[]
\tikzstyle{abstract}=[rectangle, draw=black, rounded corners, fill=gray!15, drop shadow,
        text centered, anchor=north, text=black, text width=4cm, scale=0.8]
\tikzstyle{inherit}=[->, >=triangle 90, thick]
\tikzstyle{line}=[-, thick]

\node (Token) [abstract, rectangle split, rectangle split parts=2, text width=3.3cm]
        {
            \textbf{Token}
            \nodepart{second}TokenType type\\int line\\int column\\long int value\\Key* key
        };

\node (Key) [abstract, rectangle split, rectangle split parts=2, right=of Token]
        {
            \textbf{Key}
            \nodepart{second}unsigned int hash\\Information* info
        };
\node (Information) [abstract, rectangle split, rectangle split parts=2, right=of Key]
        {
            \textbf{Information}
            \nodepart{second}const char* lexem\\\textit{(weitere für Parser)}
        };

\node (StringTab) [abstract, rectangle split, rectangle split parts=2, right=of Information, text width=2.8cm]
        {
            \textbf{StringTab}
            \nodepart{second}'a'\\'b'\\'c'\\'$\backslash0$'\\'x'\\'y'\\'z'\\'$\backslash0$'\\'$\backslash0$'\\'$\backslash0$'
        };

% Inheritance lines
\draw[inherit] (Token.east) -- (Key.west);
\draw[inherit] (Key.east) -- (Information.west);
\draw[inherit] (Information.east) -- (StringTab.west);
\end{tikzpicture}
\caption{Zusammenhang zwischen dem \code{struct} bzw. den Klassen \code{Token}, \code{Key}, \code{Information} und \code{Stringtable}.} \label{fig:tokkeyinf}
\end{center}
\end{figure}

Die Symboltabelle verfügt über drei öffentliche Methoden:
\begin{description}
\item \code{Key* Symboltable::insert(const char* lexem)} erlaubt das Einfügen eines neuen Strings.
Es wird ein Key-Objekt zurückgegeben, welches u.a. einen Pointer in die Stringtabelle enthält.
Existiert der String bereits in der Symboltabelle, wird der bereits existierende Key zurückgegeben.
\item \code{Information Symboltable::lookup(Key key)} holt exitierende Einträge aus der Tabelle.
Nützlich für den Parser.
\item \code{unsigned int Symboltable::hash(const char* lexem)} ermittelt den hash eines Lexems, ohne in die Tabelle einzufügen.
Eine Hilfsfunktion für den Scanner, der damit schneller überprüfen kann, ob ein Identifier ein Keyword ist. Siehe \ref{anc:hashcompare}.
\end{description}

Die Symboltabelle setzt sich aus folgenden zwei Bestandteilen zusammen.

\subsubsection{Hashmap}
Die eigentliche Tabelle ist eine \emph{Hashmap}, die ein schnelles Einfügen und Extrahieren von Einträgen erlaubt.
Die Hashfunktion ist in \ref{lst:hash} zu sehen.
Es handelt sich um eine recht einfache multiplikative Hashfunktion, die bei unseren Tests sehr gute Resultate ergab was Kollisionszahl und Berechnungszeit angeht.

\begin{lstlisting}[language=C++, firstnumber=172, caption={Die Hashfunktion.}, label=lst:hash]
unsigned int Symboltable::hash(const char* lexem) {
  // lexem = NULL won't work! Check beforehand!
  unsigned int hash = 0; // SEED = 0;
  int i = 0;

  while (lexem[i]) {
    // optimized: SALT = 65599 = (2^16 + 2^6 - 1)
    hash = (hash << 16) + (hash << 6) - hash + lexem[i];
    i++;
  }
  return hash;
}
\end{lstlisting}

\code{hash(const char*)} gibt den \emph{vollen Hash} zurück, welcher ebenfalls im Key gespeichert wird.
Um den eigentlich Tabellenplatz zu finden, muss noch \code{hash \% current_table_size} berechnet werden.

Mit zunehmender Anzahl von Einträgen, vergrößert sich die Tabelle.
Die Hashmap startet mit einer Größe, so dass die anfangs eingefügten 9 Keywords (mit alternativen Schreibweise) kein \code{resize()} erzeugen.
Dieser passiert bei einem \emph{Füllstand} von 75 \%.

Der Resize verdoppelt die Größe der Tabelle.
Danach müssen alle Einträge neu eingefügt werden, da sich ihr Position ändern kann.
Da wir den vollen Hash bei den Keys gespeichert haben und dieser sich bei konstantem Lexem nicht mit der Tabellengröße ändert, erleichtern wir uns an dieser Stelle die Arbeit, indem wir nur \code{Key.getHash() \% current_table_size} berechnen müssen, um die neue Position zu erhalten.

\subsubsection{Stringtabelle}
Die Stringtabelle ist ein Speicherbereich, in dem jeder angetroffene Identifier genau einmal eingetragen wird.
Hierbei liegen bei unserer Implementierung die \emph{C-style} Strings direkt hinereinander, d.h. sie werden von Nullterminatoren getrennt.
Beim Einfügen in die Symboltabelle wird im Falle einer Nicht-Kollision das entsprechende Lexem in die Stringtabelle kopiert und dabei ein Information-Objekt mit einem Zeiger auf den neuen Eintrag erzeugt.
Ist der Speicherbereich zu klein für den neuen String, wird
\begin{enumerate}
\item Ein neuer doppelt so großer Bereich allokiert. 
\item Der Inhalt des alten Bereichs hinüberkopiert.
\item Der alte Bereich freigegeben.
\item Für alle ausgegebenen Information-Objekte der Pointer angepasst.
\end{enumerate}



\section{Der Scanner} \label{sec:scanner}

\subsection{Aufgabe des Scanners}
Die Scannerklasse fasst alle vorherigen Bestandteile zusammen und ermöglicht die Generierung einer Tokensequenz mittels wiederholtem Aufruf von \code{Token Scanner::nextToken(void)}. Die Sequenz endet mit dem speziellen Token \texttt{TokenStop}, welches durch das Einlesen des Nullterminals \code{'\\0'} bzw. \texttt{EOF} erzeugt wird.


\subsection{Implementierung} \label{ssec:scanimpl}
Die Methode \code{Token Scanner::nextToken(void)} 'füttert' solange Zeichen an den Automaten, bis in einem seiner Zustände \code{void Scanner::mkToken(TokenType)} aufgerufen wird.
Dies setzt die Schleifenvariable \code{no_token = false}, so dass das Token erzeugt und zurückgegeben wird.

In Abhängigkeit des TokenTyps, geschehen noch weitere Aktionen:
\begin{description}
\item Bei TokenUnknown wird das das unbekannte Zeichen vom Automaten geholt und im Token gespeichert.
\item \label{anc:hashcompare} Bei TokenIdentifier wird geprüft, ob es sich um ein Keyword handelt.
Dazu wird erst verglichen, ob der \code{hash} des Lexems einem Keyword-hash entspricht.
Wenn dies der Fall ist, werden die Lexeme der jeweiligen Keywords mit den neuen String zeichenweise verglichen.
Falls dies Gleichheit ergibt, wird der Typ entsprechend angepasst (TokenIf, TokenWhile, etc.).
Falls der Identiier kein Keywordist, wird das Lexem vom Automaten geholt und in die Symboltabelle eingefügt.
Der von dieser erhaltene \code{Key} wird im Token gespeichert.
\item Bei TokenInteger wird der geparste Zahlenwert vom Automaten geholt und im Token gespeichert.
\end{description}

In jedem Fall wird Zeile und Spalte im Token gespeichert.

\subsection{Programmaufruf}
Die ausführbare \emph{ScannerTest} liest als Parameter eine beliebig lange Liste von Dateinamen ein. Zum Beispiel wie in Listing \ref{lst:scantest} alle Dateien eines Ordners mittels Bash-Expansion.
\begin{lstlisting}[language=PseudoCode, caption={Aufruf von ScannerTest}, label=lst:scantest]
~/project/$ ./Scanner/debug/ScannerTest tests/*
\end{lstlisting}
Im Programm wird für jede Datei jeweils ein Scanner-Objekt erzeugt. Dieses beauftragt den Buffer damit, die Datei zu öffnen. Es werden alle Zeichen eingelesen - gescannt - und die jeweiligen Ergebnistoken für alle Eingabedateien zusammen in eine Datei $out.txt$ geschrieben. Dies sieht dann zum Beispiel aus wie in Listing \ref{lst:scanout}.
\begin{lstlisting}[language=PseudoCode, firstnumber=57, caption={Dateiausgabe von ScannerTest}, label=lst:scanout]
[...]
TokenStop            in line 3     in column 0
   --- END OF Scanner/tests/empty.txt ---
   --- BEGIN Scanner/tests/theBible.txt ---
TokenIdentifier	     in line 1     in column 1      Lexem: The
TokenIdentifier	     in line 1     in column 5      Lexem: Project
TokenIdentifier	     in line 1     in column 13     Lexem: Gutenberg
TokenIdentifier      in line 1     in column 23     Lexem: EBook
[...]
\end{lstlisting}
Parallel werden mögliche Fehler und weitere Informationen auf der Console ausgegeben.




\section{Tests}
Für diverse Szenarien haben wir eine ganze Reihe von Testdateien erstellt. Einige sind im Folgenden umschrieben.

\begin{description}
\item{\texttt{anything.txt}} Ein potentiell sinnvolles Codebeispiel mit einer bunten Mischung verschiedener Tokens und Kommentare. Ein allgemeiner Testfall ohne besonderen Fokus. Eher als Parsertest nützlich.

\item{\texttt{empty.txt}} Eine komplett leere Datei, 0 Byte groß. Fokus dieses Testfalls ist die Funktion des Buffers -- also ob etwas schief geht, wenn schon zu Beginn nichts einzulesen ist.

\item{\texttt{desert.txt}} Eine Datei mit verschiedenen Whitespaces: Space, Newline und Tabulator. Fokus dieses Tests ist der Grenzfall, dass der Automat zwar viele Zeichen zu verarbeiten hat, aber nie ein Token entstehen sollte.

% \vadjust{\penalty10000} verhindert, dass die URL gepagebreaked wird ...
\item{\texttt{EquCol2.txt}} Da wir in diesem Bereich des Automaten lange Zeit Probleme hatten, die \code{line} und \code{column} korrekt anzugeben, haben wir unter \vadjust{\penalty10000}\url{http://textmechanic.com/text-tools/combination-permutation-tools/permutation-generator/}\vadjust{\penalty0} alle möglichen Permutationen von \texttt{:}, \texttt{=}, \texttt{:=}, \texttt{=:=} und \texttt{:**:} erzeugen lassen.
Ein Auszug findet sich in Quelltext \ref{lst:testEquCol2}.

\begin{lstlisting}[language=SysProgLang, caption={EquCol2.txt}, label=lst:testEquCol2]
=:=:=:=:**:
=:=::**:=:=
=:==:=::**:
=:==:=:**::
=:=:**::=:=
=:=:**:=:=:
=::=:**:=:=
=::==:=:**:
=:=:=:**::=
line10
=:=:=:=:**: 
[...]
\end{lstlisting}
Anschließend haben wir verglichen, ob
\begin{enumerate}
\item \code{Automat::line} der Anzahl der Zeilen in der Datei entspricht,
\item \code{Automat::column} niemals $< 1$ oder $> 11$ ist,
\item Die Token korrekt und an der richtigen Stelle erkannt werden. (zumindest stichprobenweise)
\end{enumerate}
Prinzipiell wäre es wünschenswert, alle möglichen Kombinationen aller Tokens zu testen. Dies würde aber mit $21! = 5 \cdot 10^{19}$ Möglichkeiten unsere Kapazitäten sprengen.

\item{\texttt{legalComments.txt}} Dieser Test fokussiert sich auf alle erdenklichen Fälle um und in Kommentaren ($:* *:$). Innerhalb sind alle Zeichen erlaubt. Insbesondere auch $":"$ und $"*"$ allein. Desweiteren endet der letzte Kommentar nicht (bzw. mit $EOF$).

% \vadjust{\penalty10000} verhindert, dass die URL gepagebreaked wird ...
\item{\texttt{theBible.txt}} Dieser Test enthält den vollständigen Text der King-James-Bibel unter \vadjust{\penalty10000}\url{http://www.gutenberg.org/cache/epub/10/pg10.txt}\vadjust{\penalty0} und dient vor allem der Performanz- und Speicherleck-Überprüfung in der Symboltabelle.

\item{\texttt{longWords.txt}} Enthält Identifier mit versch. Wortlängen, auch jenseits der doppelten Pufferbreite. Fokus ist Performanzüberprüfung der Symboltabelle.

\item{\texttt{manyWords.txt}} Enthält viele, auch sich wiederholende Identifier. Fokus ist Performanz- und Konsistenzüberprüfung der Symboltabelle bei wiederholtem \code{resize()}.

\item{\texttt{unknown.txt}} Enthält alle dem Scanner unbekannten ASCII-Zeichen, sowie entsprechend zu händelnde Situation wie unmittelbar aufeinander folgende unbekannte Zeichen und unbekannte Zeichen inmitten von Zahlen und Identifiern.

\item{\texttt{values.txt}} Enthält viele Zahlenwerte, die mit \code{strtol()} zu parsen sind.

\end{description}



%\section{Schluss?? Was wir gelernt haben? Was wir besser machen würden? Oder (nur) im Parser?}

\end{document}
